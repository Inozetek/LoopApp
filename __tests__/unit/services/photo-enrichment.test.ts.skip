/**
 * Photo Enrichment Tests
 *
 * Tests the photo enrichment functionality that fetches additional photos
 * from Google Places API when an activity only has 1 photo.
 */

import { generateRecommendations } from '@/services/recommendations';
import { supabase } from '@/lib/supabase';
import {
  createTestUser,
  cleanupTestUser,
} from '../../setup/test-helpers';

// Test timeout: 30 seconds for real API calls
jest.setTimeout(30000);

// TODO: These tests need to be updated to use the new generateRecommendations API signature
// The function now takes a single RecommendationParams object with { user, userLocation, ... }
describe.skip('Photo Enrichment', () => {
  let testUserId: string;

  beforeAll(async () => {
    // Create test user
    const { userId } = await createTestUser({
      name: 'Photo Test User',
      email: `test-photos-${Date.now()}@loopapp.com`,
      interests: ['coffee', 'restaurants'],
      ai_profile: {
        preferred_distance_miles: 5.0,
        budget_level: 2,
        favorite_categories: ['coffee', 'dining'],
        disliked_categories: [],
        price_sensitivity: 'medium',
        time_preferences: ['morning', 'evening'],
        distance_tolerance: 'medium',
      },
    });

    testUserId = userId;
  });

  afterAll(async () => {
    await cleanupTestUser(testUserId);
  });

  describe('Photo Carousel Threshold', () => {
    it('should enable carousel with 2+ photos (reduced from 3+)', async () => {
      // Get recommendations for user
      const recommendations = await generateRecommendations(testUserId, {
        latitude: 32.7767,
        longitude: -96.797,
        radius: 5000,
        limit: 20,
      });

      // Find recommendations with exactly 2 photos
      const twoPhotoRecs = recommendations.filter(
        rec => rec.photos && rec.photos.length === 2
      );

      if (twoPhotoRecs.length > 0) {
        // Verify that recommendations with 2 photos have photos array
        twoPhotoRecs.forEach(rec => {
          expect(rec.photos).toBeDefined();
          expect(rec.photos!.length).toBe(2);
        });

        console.log(`âœ… Found ${twoPhotoRecs.length} recommendations with exactly 2 photos (carousel enabled)`);
      } else {
        console.log('âš ï¸ No recommendations with exactly 2 photos found (test inconclusive)');
      }
    });

    it('should enable carousel with 3+ photos', async () => {
      const recommendations = await generateRecommendations(testUserId, {
        latitude: 32.7767,
        longitude: -96.797,
        radius: 5000,
        limit: 20,
      });

      // Find recommendations with 3+ photos
      const multiPhotoRecs = recommendations.filter(
        rec => rec.photos && rec.photos.length >= 3
      );

      if (multiPhotoRecs.length > 0) {
        multiPhotoRecs.forEach(rec => {
          expect(rec.photos).toBeDefined();
          expect(rec.photos!.length).toBeGreaterThanOrEqual(3);
        });

        console.log(`âœ… Found ${multiPhotoRecs.length} recommendations with 3+ photos`);
      }
    });

    it('should show single photo when only 1 available and enrichment fails', async () => {
      const recommendations = await generateRecommendations(testUserId, {
        latitude: 32.7767,
        longitude: -96.797,
        radius: 5000,
        limit: 20,
      });

      // Find recommendations with exactly 1 photo
      const singlePhotoRecs = recommendations.filter(
        rec => rec.photoUrl && (!rec.photos || rec.photos.length === 1)
      );

      if (singlePhotoRecs.length > 0) {
        singlePhotoRecs.forEach(rec => {
          expect(rec.photoUrl).toBeDefined();
          expect(typeof rec.photoUrl).toBe('string');
        });

        console.log(`âœ… Found ${singlePhotoRecs.length} recommendations with single photo`);
      }
    });
  });

  describe('Photo Enrichment Logic', () => {
    it('should attempt to enrich photos for places with only 1 photo', async () => {
      // This test verifies that the enrichment process runs
      // We can't directly test the internal enrichPlacePhotos function,
      // but we can verify the outcome

      const recommendations = await generateRecommendations(testUserId, {
        latitude: 32.7767,
        longitude: -96.797,
        radius: 5000,
        limit: 20,
      });

      // Check if any recommendations have 2+ photos (indicating successful enrichment)
      const enrichedRecs = recommendations.filter(
        rec => rec.photos && rec.photos.length >= 2
      );

      expect(enrichedRecs.length).toBeGreaterThan(0);
      console.log(`âœ… Photo enrichment appears to be working (${enrichedRecs.length} enriched recs)`);
    });

    it('should preserve existing photos during enrichment', async () => {
      const recommendations = await generateRecommendations(testUserId, {
        latitude: 32.7767,
        longitude: -96.797,
        radius: 5000,
        limit: 20,
      });

      // Verify that photos are valid URLs
      recommendations.forEach(rec => {
        if (rec.photos && rec.photos.length > 0) {
          rec.photos.forEach(photoUrl => {
            expect(typeof photoUrl).toBe('string');
            expect(photoUrl.length).toBeGreaterThan(0);

            // Should be a valid URL (either Google Places or other source)
            expect(
              photoUrl.startsWith('http://') ||
              photoUrl.startsWith('https://') ||
              photoUrl.startsWith('places/')
            ).toBe(true);
          });
        }
      });
    });
  });

  describe('Photo URL Format', () => {
    it('should generate valid photo URLs for Google Places photos', async () => {
      const recommendations = await generateRecommendations(testUserId, {
        latitude: 32.7767,
        longitude: -96.797,
        radius: 5000,
        limit: 20,
      });

      // Find Google Places recommendations
      const googlePlacesRecs = recommendations.filter(
        rec => rec.source === 'google_places' && rec.photoUrl
      );

      if (googlePlacesRecs.length > 0) {
        googlePlacesRecs.forEach(rec => {
          // Photo URL should be from Google Places API
          expect(rec.photoUrl).toContain('places.googleapis.com');
        });

        console.log(`âœ… Verified ${googlePlacesRecs.length} Google Places photo URLs`);
      }
    });

    it('should handle photo URLs from multiple sources', async () => {
      const recommendations = await generateRecommendations(testUserId, {
        latitude: 32.7767,
        longitude: -96.797,
        radius: 5000,
        limit: 20,
      });

      const photoSources = new Set<string>();

      recommendations.forEach(rec => {
        if (rec.photoUrl) {
          if (rec.photoUrl.includes('places.googleapis.com')) {
            photoSources.add('google_places');
          } else if (rec.photoUrl.includes('ticketmaster.com')) {
            photoSources.add('ticketmaster');
          } else {
            photoSources.add('other');
          }
        }
      });

      // Should handle photos from multiple sources
      expect(photoSources.size).toBeGreaterThan(0);
      console.log(`âœ… Photo sources: ${Array.from(photoSources).join(', ')}`);
    });
  });

  describe('Performance', () => {
    it('should fetch recommendations with photos in reasonable time', async () => {
      const startTime = Date.now();

      const recommendations = await generateRecommendations(testUserId, {
        latitude: 32.7767,
        longitude: -96.797,
        radius: 5000,
        limit: 10,
      });

      const endTime = Date.now();
      const duration = endTime - startTime;

      // Should complete within 5 seconds (including API calls and photo enrichment)
      expect(duration).toBeLessThan(5000);

      console.log(`âœ… Fetched ${recommendations.length} recommendations in ${duration}ms`);
    });

    it('should not make excessive API calls for photo enrichment', async () => {
      // This test verifies that we only enrich photos when needed
      // We can't directly measure API calls, but we can verify the behavior

      const recommendations = await generateRecommendations(testUserId, {
        latitude: 32.7767,
        longitude: -96.797,
        radius: 5000,
        limit: 20,
      });

      // Count how many recommendations have 2+ photos
      const enrichedCount = recommendations.filter(
        rec => rec.photos && rec.photos.length >= 2
      ).length;

      // Count how many have only 1 photo
      const singlePhotoCount = recommendations.filter(
        rec => rec.photoUrl && (!rec.photos || rec.photos.length === 1)
      ).length;

      console.log(`ðŸ“Š Enriched: ${enrichedCount}, Single photo: ${singlePhotoCount}`);

      // At least some recommendations should have photos
      expect(enrichedCount + singlePhotoCount).toBeGreaterThan(0);
    });
  });

  describe('Edge Cases', () => {
    it('should handle places with no photos gracefully', async () => {
      const recommendations = await generateRecommendations(testUserId, {
        latitude: 32.7767,
        longitude: -96.797,
        radius: 5000,
        limit: 20,
      });

      // Find recommendations without photos
      const noPhotoRecs = recommendations.filter(
        rec => !rec.photoUrl && (!rec.photos || rec.photos.length === 0)
      );

      if (noPhotoRecs.length > 0) {
        // Should have all other required fields
        noPhotoRecs.forEach(rec => {
          expect(rec.title).toBeDefined();
          expect(rec.category).toBeDefined();
          expect(rec.location).toBeDefined();
        });

        console.log(`âœ… ${noPhotoRecs.length} recommendations handled gracefully without photos`);
      }
    });

    it('should not fail when photo enrichment API call fails', async () => {
      // This test verifies graceful degradation
      const recommendations = await generateRecommendations(testUserId, {
        latitude: 32.7767,
        longitude: -96.797,
        radius: 5000,
        limit: 20,
      });

      // Should return recommendations even if some photo enrichment fails
      expect(recommendations.length).toBeGreaterThan(0);
    });
  });
});
