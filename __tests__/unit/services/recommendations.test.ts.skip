/**
 * Recommendation Engine Tests
 *
 * Tests the 8-data-source scoring algorithm:
 * 1. Base score (interest match, rating, popularity)
 * 2. Location score (distance, home/work proximity)
 * 3. Time context score
 * 4. Facebook liked places (exact + category)
 * 5. Google Timeline visited places
 * 6. Calendar patterns
 * 7. Budget matching
 * 8. Loop visit history + feedback
 */

import {
  generateRecommendations,
  searchNearbyPlaces,
} from '../../../services/recommendations';
import { supabase } from '../../../lib/supabase';
import {
  createTestUser,
  cleanupTestUser,
  seedTestActivities,
  cleanupTestActivities,
} from '../../setup/test-helpers';

// Test timeout: 30 seconds for real API calls
jest.setTimeout(30000);

// TODO: These tests need to be updated to use the new generateRecommendations API signature
// The function now takes a single RecommendationParams object with { user, userLocation, ... }
// instead of { userId, maxResults }
describe.skip('Recommendation Engine', () => {
  let testUserId: string;
  let testActivities: string[] = [];

  beforeAll(async () => {
    // Create test user with predefined interests
    const { userId } = await createTestUser({
      name: 'Test User',
      email: `test-rec-${Date.now()}@loopapp.com`,
      interests: ['coffee', 'live_music', 'hiking'],
      ai_profile: {
        preferred_distance_miles: 5.0,
        budget_level: 2,
        favorite_categories: ['coffee', 'live_music'],
        disliked_categories: [],
        price_sensitivity: 'medium',
        time_preferences: ['morning', 'evening'],
        distance_tolerance: 'medium',
      },
    });

    testUserId = userId;
  });

  afterAll(async () => {
    // Cleanup
    await cleanupTestUser(testUserId);
    if (testActivities.length > 0) {
      await cleanupTestActivities(testActivities);
    }
  });

  describe('Scoring Algorithm', () => {
    describe('Base Score (Interest Matching)', () => {
      it('should give 30 points for top 3 interest match', () => {
        // This would require exposing the scoring function or testing via generateRecommendations
        // For now, we'll test the integration via generateRecommendations
        expect(true).toBe(true); // Placeholder
      });

      it('should give 20 points for other interest match', () => {
        expect(true).toBe(true); // Placeholder
      });

      it('should give 10-15 points for non-matching interests based on discovery mode', () => {
        expect(true).toBe(true); // Placeholder
      });
    });

    describe('Rating & Popularity Boost', () => {
      it('should boost high-rated places (4.5+ stars)', () => {
        expect(true).toBe(true); // Placeholder
      });

      it('should boost popular places (500+ reviews)', () => {
        expect(true).toBe(true); // Placeholder
      });
    });

    describe('Location Score', () => {
      it('should give 20 points for very close places (<0.5 miles)', () => {
        expect(true).toBe(true); // Placeholder
      });

      it('should give 15 points for walking distance (<1 mile)', () => {
        expect(true).toBe(true); // Placeholder
      });

      it('should penalize places beyond max distance', () => {
        expect(true).toBe(true); // Placeholder
      });

      it('should bonus +5 for places near home', () => {
        expect(true).toBe(true); // Placeholder
      });

      it('should bonus +5 for places near work', () => {
        expect(true).toBe(true); // Placeholder
      });
    });

    describe('Time Context Score', () => {
      it('should match coffee in morning (perfect match)', () => {
        expect(true).toBe(true); // Placeholder
      });

      it('should match dinner in evening (perfect match)', () => {
        expect(true).toBe(true); // Placeholder
      });

      it('should give lower score for mismatched time context', () => {
        expect(true).toBe(true); // Placeholder
      });
    });

    describe('Data Source Integrations', () => {
      describe('Facebook Liked Places', () => {
        it('should give +30 for exact place name match', async () => {
          // Update test user with Facebook data
          const { error } = await supabase
            .from('users')
            .update({
              facebook_data: {
                liked_places: [
                  {
                    name: 'Blue Bottle Coffee',
                    category: 'coffee',
                    place_id: 'test_fb_place_1',
                  },
                ],
              },
            })
            .eq('id', testUserId);

          expect(error).toBeNull();

          // Get recommendations (should boost Blue Bottle Coffee)
          const recommendations = await generateRecommendations({
            userId: testUserId,
            maxResults: 10,
          });

          // Verify boost was applied (Blue Bottle should rank high)
          const blueBottle = recommendations.find((r) =>
            r.name.includes('Blue Bottle')
          );

          if (blueBottle) {
            expect(blueBottle.score).toBeGreaterThan(50); // Base + Facebook boost
          }
        });

        it('should give +15 for category match only', async () => {
          // Update user with different liked place
          const { error } = await supabase
            .from('users')
            .update({
              facebook_data: {
                liked_places: [
                  {
                    name: 'Some Coffee Shop',
                    category: 'coffee',
                    place_id: 'test_fb_place_2',
                  },
                ],
              },
            })
            .eq('id', testUserId);

          expect(error).toBeNull();

          // Get recommendations
          const recommendations = await generateRecommendations({
            userId: testUserId,
            maxResults: 10,
          });

          // Coffee shops should get category boost (+15)
          const coffeeShops = recommendations.filter((r) =>
            r.category.toLowerCase().includes('coffee')
          );

          expect(coffeeShops.length).toBeGreaterThan(0);
        });
      });

      describe('Google Timeline Visited Places', () => {
        it('should give +35 for frequently visited places (20+ visits)', async () => {
          const { error } = await supabase
            .from('users')
            .update({
              google_timeline: {
                visited_places: [
                  {
                    place_name: 'Starbucks',
                    category: 'coffee',
                    visit_count: 25,
                    last_visit: new Date().toISOString(),
                    lat: 37.7749,
                    lng: -122.4194,
                  },
                ],
                last_synced: new Date().toISOString(),
              },
            })
            .eq('id', testUserId);

          expect(error).toBeNull();

          const recommendations = await generateRecommendations({
            userId: testUserId,
            maxResults: 10,
          });

          // Starbucks or similar coffee shops should be highly ranked
          const coffeeShops = recommendations.filter((r) =>
            r.category.toLowerCase().includes('coffee')
          );

          expect(coffeeShops.length).toBeGreaterThan(0);
        });

        it('should apply freshness factor (boost recent visits)', async () => {
          // Recent visit (last week)
          const recentVisit = new Date();
          recentVisit.setDate(recentVisit.getDate() - 7);

          const { error } = await supabase
            .from('users')
            .update({
              google_timeline: {
                visited_places: [
                  {
                    place_name: 'Recent Coffee',
                    category: 'coffee',
                    visit_count: 5,
                    last_visit: recentVisit.toISOString(),
                    lat: 37.7749,
                    lng: -122.4194,
                  },
                ],
                last_synced: new Date().toISOString(),
              },
            })
            .eq('id', testUserId);

          expect(error).toBeNull();

          // Get recommendations
          const recommendations = await generateRecommendations({
            userId: testUserId,
            maxResults: 10,
          });

          expect(recommendations.length).toBeGreaterThan(0);
        });
      });

      describe('Budget Matching', () => {
        it('should give +15 for perfect price match', async () => {
          // User has budget_level = 2 ($$)
          // Places with price_level = 2 should get +15 boost

          const recommendations = await generateRecommendations({
            userId: testUserId,
            maxResults: 10,
          });

          // Check if recommendations include places at user's budget level
          const matchingBudget = recommendations.filter(
            (r) => r.price_range === 2
          );

          if (matchingBudget.length > 0) {
            // These should have budget boost applied
            expect(matchingBudget.length).toBeGreaterThan(0);
          }
        });

        it('should give -10 for two levels price mismatch', async () => {
          // User has budget_level = 2 ($$)
          // Places with price_level = 4 ($$$$) should get -10 penalty

          const recommendations = await generateRecommendations({
            userId: testUserId,
            maxResults: 10,
          });

          // Expensive places should be lower in ranking
          const expensivePlaces = recommendations.filter(
            (r) => r.price_range === 4
          );

          // These should be ranked lower due to penalty
          if (expensivePlaces.length > 0) {
            const avgRankExpensive =
              expensivePlaces.reduce(
                (sum, p, idx) =>
                  sum + recommendations.findIndex((r) => r.place_id === p.place_id),
                0
              ) / expensivePlaces.length;

            // Expensive places should be in bottom half of results
            expect(avgRankExpensive).toBeGreaterThan(recommendations.length / 2);
          }
        });
      });

      describe('Loop Visit History & Feedback', () => {
        it('should boost places user visited 10+ times via Loop (+40)', async () => {
          // This requires seeding visit history in calendar_events table
          // For now, placeholder
          expect(true).toBe(true);
        });

        it('should boost places with thumbs up (+15-20)', async () => {
          // Requires seeding feedback table
          // Placeholder
          expect(true).toBe(true);
        });

        it('should penalize places with thumbs down (-10 to -20)', async () => {
          // Placeholder
          expect(true).toBe(true);
        });
      });
    });
  });

  describe('Multi-Source Integration', () => {
    it('should call Google Places API successfully', async () => {
      const results = await searchNearbyPlaces({
        location: { lat: 37.7749, lng: -122.4194 }, // San Francisco
        radius: 5000, // 5km
        maxResults: 10,
      });

      expect(results).toBeDefined();
      expect(Array.isArray(results)).toBe(true);

      if (results.length > 0) {
        expect(results[0]).toHaveProperty('place_id');
        expect(results[0]).toHaveProperty('name');
        expect(results[0]).toHaveProperty('geometry');
      }
    });

    it('should include Ticketmaster events if enabled', async () => {
      // Requires EXPO_PUBLIC_ENABLE_TICKETMASTER=true
      const recommendations = await generateRecommendations({
        userId: testUserId,
        maxResults: 20,
      });

      // Check if any Ticketmaster events are included
      const events = recommendations.filter((r) => r.source === 'ticketmaster');

      // Events may or may not be present depending on availability
      console.log(`Found ${events.length} Ticketmaster events`);
    });
  });

  describe('Filtering & Ranking', () => {
    describe('Generic Place Filter', () => {
      it('should filter out McDonald\'s unless user has positive history', async () => {
        const recommendations = await generateRecommendations({
          userId: testUserId,
          maxResults: 20,
        });

        // Count how many generic places appear
        const genericPlaces = recommendations.filter(
          (r) =>
            r.name.toLowerCase().includes('mcdonald') ||
            r.name.toLowerCase().includes('walmart') ||
            r.name.toLowerCase().includes('cvs')
        );

        // Should be very few or none
        expect(genericPlaces.length).toBeLessThan(3);
      });

      it('should allow popular places (rating ≥4.0, reviews ≥50) even if generic', async () => {
        // Test that high-quality generic places are allowed
        expect(true).toBe(true); // Placeholder
      });
    });

    describe('Disliked Categories Filter', () => {
      it('should exclude activities in disliked_categories', async () => {
        // Update user to dislike nightclubs
        await supabase
          .from('users')
          .update({
            ai_profile: {
              preferred_distance_miles: 5.0,
              budget_level: 2,
              favorite_categories: ['coffee', 'live_music'],
              disliked_categories: ['nightlife', 'nightclub'],
              price_sensitivity: 'medium',
              time_preferences: ['morning', 'evening'],
              distance_tolerance: 'medium',
            },
          })
          .eq('id', testUserId);

        const recommendations = await generateRecommendations({
          userId: testUserId,
          maxResults: 20,
        });

        // Should not contain nightclubs
        const nightclubs = recommendations.filter(
          (r) =>
            r.category.toLowerCase().includes('nightlife') ||
            r.category.toLowerCase().includes('nightclub')
        );

        expect(nightclubs.length).toBe(0);
      });
    });

    describe('Diversity Check', () => {
      it('should include at least 3 unique categories in top 10', async () => {
        const recommendations = await generateRecommendations({
          userId: testUserId,
          maxResults: 10,
        });

        const categories = new Set(
          recommendations.slice(0, 10).map((r) => r.category)
        );

        expect(categories.size).toBeGreaterThanOrEqual(3);
      });

      it('should not show same category 3 times in a row', async () => {
        const recommendations = await generateRecommendations({
          userId: testUserId,
          maxResults: 20,
        });

        // Check for consecutive same category
        let maxConsecutive = 1;
        let currentConsecutive = 1;

        for (let i = 1; i < recommendations.length; i++) {
          if (recommendations[i].category === recommendations[i - 1].category) {
            currentConsecutive++;
            maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
          } else {
            currentConsecutive = 1;
          }
        }

        expect(maxConsecutive).toBeLessThan(3);
      });
    });

    describe('Sponsored Activity Limits', () => {
      it('should limit sponsored activities to max 40% of top 5', async () => {
        // Requires seeding sponsored activities
        // Placeholder
        expect(true).toBe(true);
      });

      it('should not boost irrelevant sponsored activities more than +10', async () => {
        // Placeholder
        expect(true).toBe(true);
      });
    });
  });

  describe('Distance Filtering', () => {
    it('should respect user max_distance_miles preference', async () => {
      const recommendations = await generateRecommendations({
        userId: testUserId,
        maxResults: 20,
      });

      // All recommendations should be within user's max distance (5 miles)
      recommendations.forEach((rec) => {
        if (rec.distance !== undefined) {
          expect(rec.distance).toBeLessThanOrEqual(5.5); // Allow slight buffer
        }
      });
    });

    it('should include some distant places if highly scored', async () => {
      // Even if beyond max distance, very high-quality places should appear
      // with distance penalty applied
      expect(true).toBe(true); // Placeholder
    });
  });

  describe('Recency Penalty', () => {
    it('should penalize recently shown places (-40 if <6 hours)', async () => {
      // Placeholder - requires tracking shown recommendations
      expect(true).toBe(true);
    });

    it('should reduce penalty over time (72 hours)', async () => {
      // Placeholder
      expect(true).toBe(true);
    });
  });
});
